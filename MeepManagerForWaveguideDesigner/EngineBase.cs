using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Text;
using System.IO;
using System.Text.RegularExpressions;
using System.Diagnostics;
using System.Drawing;

namespace Hslab.MeepManager.WaveguideDesigner
	{
	public abstract class EngineBase
		{

		/// <summary>注：終端のディレクトリセパレータは除外される。</summary>
		public virtual string WorkingDirectoryPath
			{
			get { return _WrokingDirectoryPath; }
			set
				{
				_WrokingDirectoryPath = value;
				_WrokingDirectoryPath = _WrokingDirectoryPath
					.Replace( '\\', Path.DirectorySeparatorChar )
					.Replace( '/', Path.DirectorySeparatorChar );
				if( _WrokingDirectoryPath[_WrokingDirectoryPath.Length - 1] == Path.DirectorySeparatorChar )
					_WrokingDirectoryPath = _WrokingDirectoryPath.Substring( 0, _WrokingDirectoryPath.Length - 1 );
				}
			}
		private string _WrokingDirectoryPath;

		public MeepMaterialType DefaultMaterial { get; set; }

		public MeepLattice GeometricLattice { get; set; }

		public MeepVector3 GlobalShift { get; set; }

		public MeepObjectCollection<MeepGeometricObject> Geometry { get; private set; }

		public MeepObjectCollection<MeepPml> PmlLayers { get; private set; }

		public double Resolution { get; set; }

		public MeepObjectCollection<MeepSource> Sources { get; private set; }

		public MeepObjectCollection<MeepFlux> FluxAnalyses { get; private set; }

		public MeepRunFunction RunFunction { get; set; }

		public bool ResizesOutputFigure { get; set; }

		public Size OutputFigureSize { get; set; }

		public delegate void LogTextOutputEventHandler(object sender,LogTextOutputEventArgs e);
		public event LogTextOutputEventHandler LogTextOutput;

		public EngineBase()
			{
			WorkingDirectoryPath = Directory.GetCurrentDirectory();
			DefaultMaterial = null;
			GeometricLattice = null;
			Geometry = new MeepObjectCollection<MeepGeometricObject>();
			PmlLayers = new MeepObjectCollection<MeepPml>();
			Resolution = 10;
			Sources = new MeepObjectCollection<MeepSource>();
			FluxAnalyses = new MeepObjectCollection<MeepFlux>();
			RunFunction = null;
			ResizesOutputFigure = true;
			OutputFigureSize = new Size( 640, 480 );
			}



		public void CreateCtlFile() { CreateCtlFile( WorkingDirectoryPath + Path.DirectorySeparatorChar + "simulation.ctl" ); }
		public void CreateCtlFile(string filename)
			{
			LogTextOutput?.Invoke( this, "====== .ctl file creation starting  ======" );

			StringBuilder sb = new StringBuilder();

			// listing used materials
			List<MeepMaterialType> materials = new List<MeepMaterialType>();
			if( DefaultMaterial != null ) materials.Add( DefaultMaterial );
			foreach( MeepGeometricObject obj in Geometry )
				if( !materials.Contains( obj.Material ) )
					materials.Add( obj.Material );
			LogTextOutput?.Invoke( this, "  complete -> listing used materials" );

			// generating code header
			sb.AppendLine( "; ========================================================================" );
			sb.AppendLine( "; ==                                                                    ==" );
			sb.AppendLine( "; ==  This code was generated by MeepManagerForWaveguideDesigner.dll.   ==" );
			sb.AppendLine( "; ==                                                                    ==" );
			sb.AppendLine( "; ========================================================================" );
			sb.AppendLine();
			LogTextOutput?.Invoke( this, "  complete -> generating code header" );

			// generating material definitions as variables
			foreach( MeepMaterialType material in materials )
				sb.AppendLine( string.Format( "(define {0} {1}) ", material.Name, material ) );
			sb.AppendLine();
			LogTextOutput?.Invoke( this, "  complete -> generating material definitions as variables" );

			// setting default-material
			if( DefaultMaterial != null )
				{
				sb.AppendLine( string.Format( "(set! default-material {0}) ", DefaultMaterial.Name ) );
				sb.AppendLine();
				}
			LogTextOutput?.Invoke( this, "  complete -> setting default-material" );

			// setting geometry-lattice
			if( GeometricLattice != null )
				{
				sb.AppendLine( string.Format( "(set! geometry-lattice {0}) ", GeometricLattice ) );
				sb.AppendLine();
				}
			LogTextOutput?.Invoke( this, "  complete -> setting geometry-lattice" );

			// setting geometry
			if( Geometry.Count != 0 )
				{
				sb.Append( "(set! geometry " );
				if( GlobalShift != MeepVector3.Zero )
					sb.Append( string.Format( "(geometric-objects-duplicates {0} 1 1 ", GlobalShift ) );
				sb.Append( "(list " );

				foreach( MeepGeometricObject obj in Geometry )		// all geometric objects constructor
					sb.Append( obj.ToString() + " " );

				sb.Append( ")" );									// (list closer
				if( GlobalShift != MeepVector3.Zero )
					sb.Append( ")" );								// (geometric-objects-duplicates closer
				sb.AppendLine( ") " );                              // (set! closer
				sb.AppendLine();
				}
			LogTextOutput?.Invoke( this, "  complete -> setting geometry" );

			// setting pml-layers
			if( PmlLayers.Count != 0 )
				{
				sb.Append( "(set! pml-layers (list " );
				foreach( MeepPml pml in PmlLayers )
					sb.Append( pml.ToString() + " " );
				sb.AppendLine( ")) " );
				sb.AppendLine();
				}
			LogTextOutput?.Invoke( this, "  complete -> setting pml-layers" );

			// setting resolution
			if( Resolution != 10 )
				{
				sb.AppendLine( string.Format( "(set! resolution {0}) ", Resolution ) );
				sb.AppendLine();
				}
			LogTextOutput?.Invoke( this, "  complete -> setting resolution" );

			// setting sources
			if( Sources.Count != 0 )
				{
				sb.Append( "(set! sources (list " );
				foreach( MeepSource src in Sources )
					sb.Append( src.ToString() + " " );
				sb.AppendLine( ")) " );
				sb.AppendLine();
				}
			LogTextOutput?.Invoke( this, "  complete -> setting sources" );

			// definition of fluxes
			foreach( MeepFlux flux in FluxAnalyses )
				sb.AppendLine( flux.ToString() + " " );
			sb.AppendLine();
			LogTextOutput?.Invoke( this, "  complete -> definition of fluxes" );

			// setting run function
			if( RunFunction != null )
				sb.AppendLine( RunFunction.ToString() + " " );
			sb.AppendLine();
			LogTextOutput?.Invoke( this, "  complete -> setting run function" );

			// generating output fluxes
			foreach( MeepFlux flux in FluxAnalyses )
				sb.AppendLine( flux.ToString( MeepFlux.CodeType.SaveFlux ) + " " );
			sb.AppendLine();
			LogTextOutput?.Invoke( this, "  complete -> generating output fluxes" );

			using( StreamWriter sw = new StreamWriter( filename ) )
				{
				try
					{
					sw.WriteLine( sb.ToString() );
					}
				catch( Exception e )
					{
					throw e;
					}
				}
			LogTextOutput?.Invoke( this, "  complete -> writing in .ctl file" );
			LogTextOutput?.Invoke( this, "====== .ctl file creation completed ======" );
			}



		public void CreateShellScript() { CreateShellScript( WorkingDirectoryPath + Path.DirectorySeparatorChar + "simulation.sh" ); }
		public void CreateShellScript(string filename)
			{
			StringBuilder sb = new StringBuilder();
			List<MeepStepFunction.MeepOutputComponent> list = GetAllOutputFunctions( RunFunction.StepFunctions );
			bool containsEps = ( list.Find( new Predicate<MeepStepFunction.MeepOutputComponent>(
				(MeepStepFunction.MeepOutputComponent func) => { return func.FunctionName == "output-epsilon"; } ) ) != null );
			Regex regex;
			string s;

			sb.AppendLine( @"#!/bin/bash" );
			sb.AppendLine( @"echo -e ""================ starting simulation     ================\r\n""" );
			sb.AppendLine( @"rm *.png" );
			sb.AppendLine( @"rm -f *.h5" );
			sb.AppendLine( @"echo -e ""================ starting meep           ================""" );
			sb.AppendLine( @"meep simulation.ctl" );
			sb.AppendLine( @"echo -e ""================ completed meep          ================\r\n""" );
			if( containsEps )
				{
				regex = new Regex( @"output-(\w)field-(\w)" );
				sb.AppendLine( "h5topng -S3 simulation-eps-*.h5" );
				int i = 1;
				foreach( MeepStepFunction.MeepOutputComponent func in list )
					{
					if( regex.IsMatch( func.FunctionName ) )
						{
						s = "simulation-" + regex.Match( func.FunctionName ).Result( "$1$2" );
						sb.AppendLine( @"echo -e ""================ target : " + i.ToString( "000" ) + @"            ================""" );
						sb.AppendLine( @"echo -e ""================ starting h5topng        ================""" );
						sb.AppendLine( @"h5topng -S3 -R -Zc dkbluered -a yarg:0.5 -A simulation-eps-*.h5 " + s + "-*.h5" );
						sb.AppendLine( @"i=1" );
						sb.AppendLine( @"for f in $(ls -1 " + s + "-*.png | sort -t'-' -k2h)" );
						sb.AppendLine( @"do" );
						sb.AppendLine( "\tmv \"$f\" $(printf \"" + s + "-%06d.png\" $i)" );
						sb.AppendLine( @"\t: $((i++))" );
						sb.AppendLine( @"done" );
						sb.AppendLine( @"i=$((i-1))" );
						sb.AppendLine( @"echo -e ""================ completed h5topng       ================\r\n""" );
						sb.AppendLine( @"echo -e ""================ starting mogrify        ================""" );
						sb.AppendLine( @"mogrify -resize " + String.Format( "{0}x{1}!", OutputFigureSize.Width, OutputFigureSize.Height ) + " " + s + "-*.png" );
						sb.AppendLine( @"echo -e ""================ completed mogrify       ================""" );
						sb.AppendLine( @"echo -e ""================ target " + i.ToString( "000" ) + @" is completed ================""" );
						}
					}
				sb.AppendLine( @"echo -e ""================ completed simulation    ================""" );
				}

			using( StreamWriter sw = new StreamWriter( filename ) )
				{
				try
					{
					sw.WriteLine( sb.ToString().Replace( "\r\n", "\n" ).Replace( "\r", "\n" ) );
					}
				catch( Exception e )
					{
					throw e;
					}
				}
			}




		public abstract void RunSimulation();
		public abstract void RunSimulation(DataReceivedEventHandler outputDataReceived, DataReceivedEventHandler errorDataReceived, EventHandler exited);




		private List<MeepStepFunction.MeepOutputComponent> GetAllOutputFunctions(IList<MeepStepFunction> funcs)
			{
			List<MeepStepFunction.MeepOutputComponent> list = new List<MeepStepFunction.MeepOutputComponent>();
			foreach( MeepStepFunction func in funcs )
				{
				if( func is MeepStepFunction.MeepOutputComponent )
					list.Add( (MeepStepFunction.MeepOutputComponent)func );
				else if( func is MeepStepFunction.MeepOutputControl )
					list.AddRange( GetAllOutputFunctions( ( (MeepStepFunction.MeepOutputControl)func ).ChildFunctions ) );
				}
			return list;
			}
		}




	public class MeepObjectCollection<T> : Collection<T>
		{
		public MeepObjectCollection() { }

		public MeepObjectCollection(IList<T> items)
			{
			AddRange( items );
			}

		public void AddRange(IList<T> items)
			{
			foreach( T item in items )
				if( item == null ) throw new ArgumentException();
				else this.Add( item );
			}

		protected override void SetItem(int index, T item)
			{
			if( item == null ) throw new ArgumentNullException();
			base.SetItem( index, item );
			}


		protected override void InsertItem(int index, T item)
			{
			if( item == null ) throw new ArgumentNullException();
			base.InsertItem( index, item );
			}
		}



	public class LogTextOutputEventArgs:EventArgs
		{
		public string Message { get; private set; }
		internal LogTextOutputEventArgs(string message)
			{
			Message = message;
			}

		public static implicit operator LogTextOutputEventArgs(string text)
			{
			return new LogTextOutputEventArgs( text );
			} 
		}
	}
